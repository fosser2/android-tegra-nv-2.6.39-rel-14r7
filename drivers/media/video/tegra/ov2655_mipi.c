/*
 * kernel/drivers/media/video/tegra
 *
 * OmniVision OV2655 sensor driver
 *
 * Copyright (C) 2012, Wanlida Group Co;Ltd.
 *
 * This software is licensed under the terms of the GNU General Public
 * License version 2, as published by the Free Software Foundation, and
 * may be copied, distributed, and modified under those terms.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#include <linux/delay.h>
#include <linux/fs.h>
#include <linux/i2c.h>
#include <linux/miscdevice.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <media/ov2655_mipi.h>

#define SENSOR_NAME     "ov2655_mipi"

#define SENSOR_WAIT_MS      0  /* special number to indicate the wait time */
#define SENSOR_TABLE_END    1  /* special number to indicate the end of table */
#define SENSOR_MAX_RETRIES  3 /* max counter for retry I2C access */

struct ov2655_mode {
	int xres;
	int yres;
};

struct sensor_reg {
	u16 addr;
	u8 val;
};

struct sensor_info {
	int mode;
	struct i2c_client *i2c_client;
	struct ov2655_mipi_platform_data *pdata;
};

static struct sensor_info *info;

enum {
	YUV_ColorEffect = 0,
	YUV_Whitebalance,
	YUV_SceneMode,
	YUV_Exposure
};

enum {
	YUV_ColorEffect_Invalid = 0,
	YUV_ColorEffect_Aqua,
	YUV_ColorEffect_Blackboard,
	YUV_ColorEffect_Mono,
	YUV_ColorEffect_Negative,
	YUV_ColorEffect_None,
	YUV_ColorEffect_Posterize,
	YUV_ColorEffect_Sepia,
	YUV_ColorEffect_Solarize,
	YUV_ColorEffect_Whiteboard
};

enum {
	YUV_Whitebalance_Invalid = 0,
	YUV_Whitebalance_Auto,
	YUV_Whitebalance_Incandescent,
	YUV_Whitebalance_Fluorescent,
	YUV_Whitebalance_WarmFluorescent,
	YUV_Whitebalance_Daylight,
	YUV_Whitebalance_CloudyDaylight,
	YUV_Whitebalance_Shade,
	YUV_Whitebalance_Twilight,
	YUV_Whitebalance_Custom
};

enum {
	YUV_SceneMode_Invalid = 0,
	YUV_SceneMode_Auto,
	YUV_SceneMode_Action,
	YUV_SceneMode_Portrait,
	YUV_SceneMode_Landscape,
	YUV_SceneMode_Beach,
	YUV_SceneMode_Candlelight,
	YUV_SceneMode_Fireworks,
	YUV_SceneMode_Night,
	YUV_SceneMode_NightPortrait,
	YUV_SceneMode_Party,
	YUV_SceneMode_Snow,
	YUV_SceneMode_Sports,
	YUV_SceneMode_SteadyPhoto,
	YUV_SceneMode_Sunset,
	YUV_SceneMode_Theatre,
	YUV_SceneMode_Barcode
};

enum {
	YUV_Exposure_Invalid = 0,
	YUV_Exposure_Positive2,
	YUV_Exposure_Positive1,
	YUV_Exposure_Number0,
	YUV_Exposure_Negative1,
	YUV_Exposure_Negative2,
};

static struct sensor_reg mode_1600x1200[] = {
{0x300e,0x34},
{0x3011,0x01},
{0x3012,0x00},
{0x302A,0x04},
{0x302B,0xd4},
{0x306f,0x54},
{0x3020,0x01},
{0x3021,0x18},
{0x3022,0x00},
{0x3023,0x0a},
{0x3024,0x06},
{0x3025,0x58},
{0x3026,0x04},
{0x3027,0xbc},
{0x3088,0x06},
{0x3089,0x40},
{0x308a,0x04},
{0x308b,0xb0},
{0x3316,0x64},
{0x3317,0x4b},
{0x3318,0x00},
{0x3319,0x2c},
{0x331a,0x64},
{0x331b,0x4b},
{0x331c,0x00},
{0x331d,0x4c},
{0x3302,0x01},
{SENSOR_WAIT_MS, 100},
{SENSOR_TABLE_END, 0x00}
};


/* return_preview_uxga_to_vga */
static struct sensor_reg return_to_vga[] = {
{0x3014,0x84},
{0x302d,0x00},
{0x302e,0x00},
{0x3304,0x00},
{0x301c,0x05},
{0x300e,0x34},
{0x3011,0x01},
{0x3012,0x10},
{0x302A,0x02},
{0x302B,0x6a},
{0x306f,0x14},
{0x3020,0x01},
{0x3021,0x18},
{0x3022,0x00},
{0x3023,0x06},
{0x3024,0x06},
{0x3025,0x58},
{0x3026,0x02},
{0x3027,0x61},
{0x3088,0x02},
{0x3089,0x80},
{0x308a,0x01},
{0x308b,0xe0},
{0x3316,0x64},
{0x3317,0x25},
{0x3318,0x80},
{0x3319,0x08},
{0x331a,0x28},
{0x331b,0x1e},
{0x331c,0x00},
{0x331d,0x38},
{0x3302,0x11},
{0x3014,0xa4},
{SENSOR_WAIT_MS, 100},
{SENSOR_TABLE_END, 0x00}
};
static struct sensor_reg mode_800x600[] = {
{0x3012,0x80},
/* Add some dealy or wait a few miliseconds
after register reset */
{SENSOR_WAIT_MS, 50},
{0x308c,0x80},
{0x308d,0x0e},
{0x360b,0x00},
{0x30b0,0xff},
{0x30b1,0xff},
{0x30b2,0x04},
{0x300e,0x34},
{0x300f,0xa6},
{0x3010,0x81},
{0x3082,0x01},
{0x30f4,0x01},
{0x3091,0xc0},
{0x30ac,0x42},
{0x30d1,0x08},
{0x30a8,0x55},
{0x3015,0x02},
{0x3093,0x00},
{0x307e,0xe5},
{0x3079,0x00},
{0x30aa,0x42},
{0x3017,0x40},
{0x30f3,0x83},
{0x306a,0x0c},
{0x306d,0x00},
{0x336a,0x3c},
{0x3076,0x6a},
{0x30d9,0x95},
{0x3016,0x82},
{0x3601,0x30},
{0x304e,0x88},
{0x30f1,0x82},
{0x306f,0x14},
{0x3012,0x10},
{0x3011,0x01},
{0x302a,0x02},
{0x302b,0xe6},
{0x3028,0x07},
{0x3029,0x93},
{0x3391,0x06},
{0x3394,0x38},
{0x3395,0x38},
/* AEC/AGC */
{0x3013,0xf7},
{0x3018,0x78},
{0x3019,0x68},
{0x301a,0xd4},
/* D5060 */
{0x30af,0x00},
{0x3048,0x1f},
{0x3049,0x4e},
{0x304a,0x20},
{0x304f,0x20},
{0x304b,0x02},
{0x304c,0x00},
{0x304d,0x02},
{0x304f,0x20},
{0x30a3,0x10},
{0x3013,0xf7},
{0x3014,0x84},
{0x3071,0x00},
{0x3070,0x5d},
{0x3073,0x00},
{0x3072,0x4d},
{0x301c,0x07},
{0x301d,0x08},
{0x304d,0x42},
{0x304a,0x40},
{0x304f,0x40},
{0x3095,0x07},
{0x3096,0x16},
{0x3097,0x1d},
/* Window Setup */
{0x3020,0x01},
{0x3021,0x18},
{0x3022,0x00},
{0x3023,0x06},
{0x3024,0x06},
{0x3025,0x58},
{0x3026,0x02},
{0x3027,0x5e},
{0x3088,0x03},
{0x3089,0x20},
{0x308a,0x02},
{0x308b,0x58},
{0x3316,0x64},
{0x3317,0x25},
{0x3318,0x80},
{0x3319,0x08},
{0x331a,0x64},
{0x331b,0x4b},
{0x331c,0x00},
{0x331d,0x38},
{0x3100,0x00},
/* AWB */
{0x3320, 0xfa},
{0x3321, 0x11},
{0x3322, 0x92},
{0x3323, 0x01},
{0x3324, 0x97},
{0x3325, 0x02},
{0x3326, 0xff},
{0x3327, 0x0e},
{0x3328, 0x0e},
{0x3329, 0x17},
{0x332a, 0x60},
{0x332b, 0x4d},
{0x332c, 0x95},
{0x332d, 0xa4},
{0x332e, 0x39},
{0x332f, 0x32},
{0x3330, 0x52},
{0x3331, 0x3f},
{0x3332, 0xf0},
{0x3333, 0x0a},
{0x3334, 0xf0},
{0x3335, 0xf0},
{0x3336, 0xf0},
{0x3337, 0x40},
{0x3338, 0x40},
{0x3339, 0x40},
{0x333a, 0x00},
{0x333b, 0x00},
/* Color Matrix */
{0x3380,0x28},
{0x3381,0x48},
{0x3382,0x10},
{0x3383,0x22},
{0x3384,0xc0},
{0x3385,0xe2},
{0x3386,0xe2},
{0x3387,0xf2},
{0x3388,0x10},
{0x3389,0x98},
{0x338a,0x00},
/* Gamma */
{0x3340,0x04},
{0x3341,0x07},
{0x3342,0x19},
{0x3343,0x34},
{0x3344,0x4a},
{0x3345,0x5a},
{0x3346,0x67},
{0x3347,0x71},
{0x3348,0x7c},
{0x3349,0x8c},
{0x334a,0x9b},
{0x334b,0xa9},
{0x334c,0xc0},
{0x334d,0xd5},
{0x334e,0xe8},
{0x334f,0x20},
/* Lens correction */
{0x3350, 0x31},
{0x3351, 0x24},
{0x3352, 0x46},
{0x3353, 0x62},
{0x3354, 0x00},
{0x3355, 0x07},
{0x3356, 0x32},
{0x3357, 0x24},
{0x3358, 0x77},
{0x3359, 0x56},
{0x335a, 0x00},
{0x335b, 0x07},
{0x335c, 0x30},
{0x335d, 0x24},
{0x335e, 0x41},
{0x335f, 0x4c},
{0x3360, 0x00},
{0x3361, 0x07},
{0x3363, 0x70},
{0x3364, 0x7f},
{0x3365, 0x00},
{0x3366, 0x00},
/* UVadjust */
{0x3301,0xff},
{0x338B,0x11},
{0x338c,0x10},
{0x338d,0x40},
/* Sharpness/De-noise */
{0x3370,0xd0},
{0x3371,0x00},
{0x3372,0x00},
{0x3373,0x30},
{0x3374,0x10},
{0x3375,0x10},
{0x3376,0x07},
{0x3377,0x00},
{0x3378,0x04},
{0x3379,0x40},
/* BLC */
{0x3069,0x86},
{0x3087,0x02},
/* Other functions */
{0x3300,0xf8},
{0x3302,0x11},
{0x3400,0x02},
{0x3606,0x20},
{0x3601,0x30},
{0x30f3,0x83},
{0x304e,0x88},
{0x3015,0x02},
{0x302d,0x00},
{0x302e,0x00},
{0x3306,0x00},
{0x363b,0x01},
{0x363c,0xf2},
{0x3086,0x0f},
{0x3086,0x00},
{0x30a1,0x41},
{0x30a3,0x80},
{0x30a8,0x56},
{0x30aa,0x72},
{0x30af,0x10},
{0x30b2,0x2c},
{0x30d9,0x8c},
{SENSOR_WAIT_MS, 100},
{SENSOR_TABLE_END, 0x00}
};

static struct sensor_reg mode_1600x1200_svga_to_uxga[] = {
/* SVGA TO UXGA */
{0x300e,0x34},
{0x300f,0xa6},
{0x3012,0x00},
{0x302A,0x05},
{0x302B,0xcb},
{0x306f,0x54},
{0x3070,0x5d},
{0x3072,0x5d},
{0x301c,0x0f},
{0x3020,0x01},
{0x3021,0x18},
{0x3022,0x00},
{0x3023,0x0a},
{0x3024,0x06},
{0x3025,0x58},
{0x3026,0x04},
{0x3027,0xbc},
{0x3088,0x06},
{0x3089,0x40},
{0x308a,0x04},
{0x308b,0xb0},
{0x3316,0x64},
{0x3317,0x4b},
{0x3318,0x00},
{0x3319,0x6c},
{0x331a,0x64},
{0x331b,0x4b},
{0x331c,0x00},
{0x331d,0x6c},
{0x3302,0x01},
{0x3362,0x80},
{0x3373,0x40},
{SENSOR_WAIT_MS, 100},
{SENSOR_TABLE_END, 0x00}
};


static struct sensor_reg return_preview_uxga_to_svga[] = {
/* UXGA TO SVGA */
{0x300e,0x34},
{0x300f,0xa6},
{0x3012,0x10},
{0x302A,0x02},
{0x302B,0xe6},
{0x306f,0x14},
{0x3070,0x5d},
{0x3072,0x5d},
{0x301c,0x07},
{0x301d,0x07},
{0x3020,0x01},
{0x3021,0x18},
{0x3022,0x00},
{0x3023,0x06},
{0x3024,0x06},
{0x3025,0x58},
{0x3026,0x02},
{0x3027,0x5e},
{0x3088,0x03},
{0x3089,0x20},
{0x308a,0x02},
{0x308b,0x58},
{0x3316,0x64},
{0x3317,0x25},
{0x3318,0x80},
{0x3319,0x08},
{0x331a,0x64},
{0x331b,0x4b},
{0x331c,0x00},
{0x331d,0x38},
{0x3302,0x11},
{0x3362,0x90},
{0x3373,0x30},
{SENSOR_WAIT_MS, 100},
{SENSOR_TABLE_END, 0x00}
};

static struct sensor_reg mode_1280x720[] = {
{SENSOR_WAIT_MS, 10},

{SENSOR_WAIT_MS, 100},
{SENSOR_TABLE_END, 0x00}

};


static struct sensor_reg mode_640x480[] = {
/*
 * OV2655R1D_A02M.ovd, VGA(YUV) 15fps
 * IO & Clock & Analog Setup
  */
/* @@VGA 15fps forMLT */
{0x3012,0x80},
/* 
 * Add some dealy or wait a few miliseconds after register reset.
 */
{SENSOR_WAIT_MS, 50},
{0x308c, 0x80},
{0x308d, 0x0e},
{0x360b, 0x00},
{0x30b0, 0xff},
{0x30b1, 0xff},
{0x30b2, 0x04},
{0x300e, 0x34},
{0x300f, 0xa6},
{0x3010, 0x81},
{0x3082, 0x01},
{0x30f4, 0x01},
{0x3090, 0x43},
{0x3091, 0xc0},
{0x30ac, 0x42},
{0x30d1, 0x08},
{0x30a8, 0x54},
{0x3015, 0x02},
{0x3093, 0x00},
{0x307e, 0xe5},
{0x3079, 0x00},
{0x30aa, 0x52},
{0x3017, 0x40},
{0x30f3, 0x83},
{0x306a, 0x0c},
{0x306d, 0x00},
{0x336a, 0x3c},
{0x3076, 0x6a},
{0x30d9, 0x95},
{0x3016, 0x52},
{0x3601, 0x30},
{0x304e, 0x88},
{0x30f1, 0x82},
{0x306f, 0x14},
{0x302a, 0x02},
{0x302b, 0x6a},
{0x3012, 0x10},
{0x3011, 0x01},  /* 15fps */
/* AEC/AGC */
{0x3013, 0xf7},
{0x3018, 0x70},
{0x3019, 0x60},
{0x301a, 0xd4},
{0x301c, 0x13},
{0x301d, 0x17},
{0x3070, 0x5d},
{0x3072, 0x4d},
/* D5060 */
{0x30af, 0x00},
{0x3048, 0x1f},
{0x3049, 0x4e},
{0x304a, 0x20},
{0x304f, 0x20},
{0x304b, 0x02},
{0x304c, 0x00},
{0x304d, 0x02},
{0x304f, 0x20},
{0x30a3, 0x10},
{0x3013, 0xf7},
{0x3014, 0x64},
{0x3071, 0x00},
{0x3070, 0x5d},
{0x3073, 0x00},
{0x3072, 0x4d},
{0x301c, 0x05},
{0x301d, 0x06},
{0x304d, 0x42},
{0x304a, 0x40},
{0x304f, 0x40},
{0x3095, 0x07},
{0x3096, 0x16},
{0x3097, 0x1d},
/* Window Setup */
{0x3020, 0x01},
{0x3021, 0x18},
{0x3022, 0x00},
{0x3023, 0x06},
{0x3024, 0x06},
{0x3025, 0x58},
{0x3026, 0x02},
{0x3027, 0x61},
{0x3088, 0x02},
{0x3089, 0x80},
{0x308a, 0x01},
{0x308b, 0xe0},
{0x3316, 0x64},
{0x3317, 0x25},
{0x3318, 0x80},
{0x3319, 0x08},
{0x331a, 0x28},
{0x331b, 0x1e},
{0x331c, 0x00},
{0x331d, 0x38},
{0x3100, 0x00},
/* AWB */
{0x3320, 0xfa},
{0x3321, 0x11},
{0x3322, 0x92},
{0x3323, 0x01},
{0x3324, 0x97},
{0x3325, 0x02},
{0x3326, 0xff},
{0x3327, 0x10},
{0x3328, 0x10},
{0x3329, 0x1f},
{0x332a, 0x58},
{0x332b, 0x50},
{0x332c, 0xbe},
{0x332d, 0xce},
{0x332e, 0x2e},
{0x332f, 0x36},
{0x3330, 0x4d},
{0x3331, 0x44},
{0x3332, 0xf0},
{0x3333, 0x0a},
{0x3334, 0xf0},
{0x3335, 0xf0},
{0x3336, 0xf0},
{0x3337, 0x40},
{0x3338, 0x40},
{0x3339, 0x40},
{0x333a, 0x00},
{0x333b, 0x00},
/* Color Matrix */
{0x3380, 0x20},
{0x3381, 0x5b},
{0x3382, 0x05},
{0x3383, 0x22},
{0x3384, 0x9d},
{0x3385, 0xc0},
{0x3386, 0xb6},
{0x3387, 0xb5},
{0x3388, 0x02},
{0x3389, 0x98},
{0x338a, 0x00},
/* Gamma */
{0x3340, 0x09},
{0x3341, 0x19},
{0x3342, 0x2f},
{0x3343, 0x45},
{0x3344, 0x5a},
{0x3345, 0x69},
{0x3346, 0x75},
{0x3347, 0x7e},
{0x3348, 0x88},
{0x3349, 0x96},
{0x334a, 0xa3},
{0x334b, 0xaf},
{0x334c, 0xc4},
{0x334d, 0xd7},
{0x334e, 0xe8},
{0x334f, 0x20},
/* Lens correction */
{0x3350, 0x32},
{0x3351, 0x25},
{0x3352, 0x80},
{0x3353, 0x1e},
{0x3354, 0x00},
{0x3355, 0x84},
{0x3356, 0x32},
{0x3357, 0x25},
{0x3358, 0x80},
{0x3359, 0x1b},
{0x335a, 0x00},
{0x335b, 0x84},
{0x335c, 0x32},
{0x335d, 0x25},
{0x335e, 0x80},
{0x335f, 0x1b},
{0x3360, 0x00},
{0x3361, 0x84},
{0x3363, 0x70},
{0x3364, 0x7f},
{0x3365, 0x00},
{0x3366, 0x00},
/* UVadjust */
{0x3301, 0xff},
{0x338B, 0x1b},
{0x338c, 0x1f},
{0x338d, 0x40},
/* Sharpness/De-noise */
{0x3370, 0xd0},
{0x3371, 0x00},
{0x3372, 0x00},
{0x3373, 0x40},
{0x3374, 0x10},
{0x3375, 0x10},
{0x3376, 0x04},
{0x3377, 0x00},
{0x3378, 0x04},
{0x3379, 0x80},
/* BLC */
{0x3069, 0x86},
{0x307c, 0x10},
{0x3087, 0x02},
/*
 * black sun 
 * Avdd 2.55~3.0V
 */
{0x3090, 0x03},
{0x30a8, 0x54},
{0x30aa, 0x82},
{0x30a3, 0x91},
{0x30a1, 0x41},
/* Other functions */
{0x3300, 0xfc},
{0x3302, 0x11},
{0x3400, 0x00},
{0x3606, 0x20},
{0x3601, 0x30},
{0x300e, 0x34},
{0x30f3, 0x83},
{0x304e, 0x88},


/*
 * union1205 IQ Setting
 */
/* cmx */
{0x3380, 0x27},
{0x3381, 0x5c},
{0x3382, 0x0a},
{0x3383, 0x2f},
{0x3384, 0xc7},
{0x3385, 0xf7},
{0x3386, 0xea},
{0x3387, 0xe7},
{0x3388, 0x03},
{0x3389, 0x98},
{0x338a, 0x01},
/* awb */
{0x3320, 0xfa},
{0x3321, 0x11},
{0x3322, 0x92},
{0x3323, 0x1 },
{0x3324, 0x97},
{0x3325, 0x2 },
{0x3326, 0xff},
{0x3327, 0xc },
{0x3328, 0x10},
{0x3329, 0x13},
{0x332a, 0x58},
{0x332b, 0x5f},
{0x332c, 0xbe},
{0x332d, 0x9b},
{0x332e, 0x3a},
{0x332f, 0x36},
{0x3330, 0x4d},
{0x3331, 0x44},
{0x3332, 0xf0},
{0x3333, 0xa },
{0x3334, 0xf0},
{0x3335, 0xf0},
{0x3336, 0xf0},
{0x3337, 0x40},
{0x3338, 0x40},
{0x3339, 0x40},
{0x333a, 0x0 },
{0x333b, 0x0 },
/* lens correction */
{0x3300, 0xFC},
/* R */
{0x3350, 0x32},
{0x3351, 0x2a},
{0x3352, 0x08},
{0x3353, 0x27},
{0x3354, 0x00},
{0x3355, 0x85},
/* G */
{0x3356, 0x33},
{0x3357, 0x2a},
{0x3358, 0x08},
{0x3359, 0x24},
{0x335a, 0x00},
{0x335b, 0x85},
/* B */
{0x335c, 0x32},
{0x335d, 0x2a},
{0x335e, 0x08},
{0x335f, 0x20},
{0x3360, 0x00},
{0x3361, 0x85},
{0x3363, 0x01},
{0x3364, 0x03},
{0x3365, 0x02},
{0x3366, 0x00},
/* gamma */
{0x334f, 0x20},
{0x3340, 0x8 },
{0x3341, 0x16},
{0x3342, 0x2f},
{0x3343, 0x45},
{0x3344, 0x56},
{0x3345, 0x66},
{0x3346, 0x72},
{0x3347, 0x7c},
{0x3348, 0x86},
{0x3349, 0x96},
{0x334a, 0xa3},
{0x334b, 0xaf},
{0x334c, 0xc4},
{0x334d, 0xd7},
{0x334e, 0xe8},
/* ae */
{0x3018, 0x80},
{0x3019, 0x70},
{0x301a, 0xd4},
{0x3320 ,0xfa},
{0x3321 ,0x11},
{0x3322 ,0x92},
{0x3323 ,0x1 },
{0x3324 ,0x97},
{0x3325 ,0x2 },
{0x3326 ,0xff},
{0x3327 ,0xb },
{0x3328 ,0x12},
{0x3329 ,0xd },
{0x332a ,0x54},
{0x332b ,0x50},
{0x332c ,0xc6},
{0x332d ,0xdd},
{0x332e ,0x30},
{0x332f ,0x34},
{0x3330 ,0x3a},
{0x3331 ,0x47},
{0x3332 ,0xf8},
{0x3333 ,0xa },
{0x3334 ,0xf0},
{0x3335 ,0xf0},
{0x3336 ,0xf0},
{0x3337 ,0x40},
{0x3338 ,0x40},
{0x3339 ,0x40},
{0x333a ,0x0 },
{0x333b ,0x0 },
{0x3380 ,0x28},
{0x3381 ,0x48},
{0x3382 ,0x10},
{0x3383 ,0x1c},
{0x3384 ,0x9a},
{0x3385 ,0xb7},
{0x3386 ,0xc2},
{0x3387 ,0xb3},
{0x3388 ,0xe },
{0x3389 ,0x98},
{0x338a ,0x1 },
{0x334f ,0x1a},
{0x3340 ,0x8 },
{0x3341 ,0x13},
{0x3342 ,0x2b},
{0x3343 ,0x40},
{0x3344 ,0x55},
{0x3345 ,0x64},
{0x3346 ,0x6f},
{0x3347 ,0x78},
{0x3348 ,0x84},
{0x3349 ,0x94},
{0x334a ,0xa3},
{0x334b ,0xb2},
{0x334c ,0xc8},
{0x334d ,0xdd},
{0x334e ,0xec},
{0x3300 ,0xfc},
{0x3350 ,0x31},
{0x3351 ,0x25},
{0x3352 ,0xB6},
{0x3353 ,0x45},
{0x3354 ,0x28},
{0x3355 ,0x66},
{0x3356 ,0x32},
{0x3357 ,0x25},
{0x3358 ,0x9F},
{0x3359 ,0x3E},
{0x335A ,0x43},
{0x335B ,0x66},
{0x335C ,0x30},
{0x335D ,0x25},
{0x335E ,0xFe},
{0x335F ,0x37},
{0x3360 ,0x34},
{0x3361 ,0x66},
{0x3018 ,0x80},
{0x3019 ,0x70},
{0x301a ,0xb3},
{0x3015 ,0x02},


/*
 * pclk=18M
 * frame rate:15fps
 * YUV VGA (640x480)
 */
{0x3013, 0x05},
{0x300e, 0x3a},
{0x3010, 0x81},
{0x3012, 0x10},
{0x3015, 0x02},
{0x3016, 0x82},
{0x3023, 0x6 },
{0x3026, 0x2 },
{0x3027, 0x5e},
{0x302a, 0x2 },
{0x302b, 0x6a},
{0x330c, 0x00},
{0x3301, 0xff},
{0x3069, 0x80},
{0x306f, 0x14},
{0x3088, 0x3 },
{0x3089, 0x20},
{0x308a, 0x2 },
{0x308b, 0x58},
{0x308e, 0x0 },
{0x30a1, 0x41},
{0x30a3, 0x80},
{0x30d9, 0x95},
{0x3302, 0x11},
{0x3317, 0x25},
{0x3318, 0x80},
{0x3319, 0x8 },
{0x331d, 0x38},
{0x3373, 0x30},
{0x3376, 0x04},
{0x3362, 0x90},
/* svga->vga */
{0x3302, 0x11},
{0x3088, 0x02},
{0x3089, 0x80},
{0x308a, 0x01},
{0x308b, 0xe0},
{0x331a, 0x28},
{0x331b, 0x1e},
{0x331c, 0x00},
{0x3302, 0x11},
/* mipi */
{0x363b, 0x01},
{0x309e, 0x08},
{0x3606, 0x00},
{0x3630, 0x35},
{0x3086, 0x0f},
{0x3086, 0x00},
{0x304e, 0x04},
{0x363b, 0x01},
{0x309e, 0x08},
{0x3606, 0x00},
{0x3084, 0x01},
{0x3010, 0x81},
{0x3011, 0x00},
{0x300e, 0x3a},
{0x3634, 0x26},
{0x3086, 0x0f},
{0x3086, 0x00},

{SENSOR_WAIT_MS, 100},
{SENSOR_TABLE_END, 0x00}
};


static struct sensor_reg ColorEffect_None[] = {
{0x3301,0xff},
{0x3391,0x00},
{SENSOR_TABLE_END, 0x00}
};

static struct sensor_reg ColorEffect_Mono[] = {
{0x3301,0xff},
{0x3391,0x20},
{SENSOR_TABLE_END, 0x00}
};

static struct sensor_reg ColorEffect_Sepia[] = {
{0x3301,0xff},
{0x3391, 0x18},
{0x3396, 0x40},
{0x3397, 0xa6},
{SENSOR_TABLE_END, 0x00}
};

static struct sensor_reg ColorEffect_Negative[] = {
{0x3301,0xff},
{0x3391, 0x40},
{SENSOR_TABLE_END, 0x00}
};

static struct sensor_reg ColorEffect_Solarize[] = {

{SENSOR_TABLE_END, 0x00}
};

/*Sensor ISP Not Support this function */
static struct sensor_reg ColorEffect_Posterize[] = {
{SENSOR_TABLE_END, 0x00}
};

static struct sensor_reg Whitebalance_Auto[] = {
{0x3306, 0x00},
{SENSOR_TABLE_END, 0x00}
};

static struct sensor_reg Whitebalance_Incandescent[] = {
{0x3306, 0x02},
{0x3337, 0x5e},
{0x3338, 0x40},
{0x3339, 0x58},
{SENSOR_TABLE_END, 0x00}
};

static struct sensor_reg Whitebalance_Daylight[] = {
{0x3306, 0x02},
{0x3337, 0x5e},
{0x3338, 0x40},
{0x3339, 0x46},
{SENSOR_TABLE_END, 0x00}
};

static struct sensor_reg Whitebalance_Fluorescent[] = {
{0x3306, 0x02},
{0x3337, 0x65},
{0x3338, 0x40},
{0x3339, 0x41},
{SENSOR_TABLE_END, 0x00}
};

static struct sensor_reg Whitebalance_Cloudy[] = {
{0x3306, 0x02},
{0x3337, 0x68},
{0x3337, 0x40},
{0x3337, 0x4e},
{SENSOR_TABLE_END, 0x00}
};

static struct sensor_reg Exposure_2[] = {
{0x3047,0x05},
{0x3018,0xa8},
{0x3019,0x98},
{0x301a,0xe6},
{SENSOR_TABLE_END, 0x00}
};

static struct sensor_reg Exposure_1[] = {
{0x3047,0x05},
{0x3018,0x88},
{0x3019,0x78},
{0x301a,0xd5},
{SENSOR_TABLE_END, 0x00}
};

static struct sensor_reg Exposure_0[] = {
{0x3047,0x05},
{0x3018,0x78},
{0x3019,0x68},
{0x301a,0xd4},
{SENSOR_TABLE_END, 0x00}
};

static struct sensor_reg Exposure_Negative_1[] = {
{0x3047,0x05},
{0x3018,0x6a},
{0x3019,0x5a},
{0x301a,0xd4},
{SENSOR_TABLE_END, 0x00}
};

static struct sensor_reg Exposure_Negative_2[] = {
{0x3047,0x05},
{0x3018,0x5a},
{0x3019,0x4a},
{0x301a,0xc2},
{SENSOR_TABLE_END, 0x00}
};

enum {
	SENSOR_MODE_1600x1200,
	SENSOR_MODE_1280x720,
	SENSOR_MODE_800x600,
	SENSOR_MODE_640x480,
};

static struct sensor_reg *mode_table[] = {
	[SENSOR_MODE_1600x1200] = mode_1600x1200_svga_to_uxga,
	[SENSOR_MODE_1280x720] = mode_1280x720,
	[SENSOR_MODE_800x600]  = mode_800x600,
	[SENSOR_MODE_640x480]   = mode_640x480,
};

static int sensor_read_reg(struct i2c_client *client, u16 addr, u8 *val)
{
	int err;
	struct i2c_msg msg[2];
	unsigned char data[3];

	if (!client->adapter)
		return -ENODEV;

	msg[0].addr = client->addr;
	msg[0].flags = 0;
	msg[0].len = 2;
	msg[0].buf = data;

	/* high byte goes out first */
	data[0] = (u8) (addr >> 8);;
	data[1] = (u8) (addr & 0xff);

	msg[1].addr = client->addr;
	msg[1].flags = I2C_M_RD;
	msg[1].len = 1;
	msg[1].buf = data + 2;

	err = i2c_transfer(client->adapter, msg, 2);

	if (err != 2)
		return -EINVAL;

	/* swap high and low byte to match table format */
	memcpy(val, data+2, 1);

	return 0;
}

static int sensor_write_reg(struct i2c_client *client, u16 addr, u8 val)
{
	int err;
	struct i2c_msg msg;
	unsigned char data[3];
	int retry = 0;

	if (!client->adapter)
		return -ENODEV;

	data[0] = (u8) (addr >> 8);
	data[1] = (u8) (addr & 0xff);
	data[2] = val;

	msg.addr = client->addr;
	msg.flags = 0;
	msg.len = 3;
	msg.buf = data;

	do {
		err = i2c_transfer(client->adapter, &msg, 1);
		if (err == 1)
			return 0;
		retry++;
		pr_err("yuv_sensor : i2c transfer failed, retrying %x %x\n",
			addr, val);
		msleep(8);
	} while (retry <= SENSOR_MAX_RETRIES);

	return err;
}

static int sensor_write_table(struct i2c_client *client,
					const struct sensor_reg table[])
{
	int err;
	const struct sensor_reg *next;
	u8 val;

	for (next = table; next->addr != SENSOR_TABLE_END; next++) {
		if (next->addr == SENSOR_WAIT_MS) {
			msleep(next->val);
			continue;
		}

		val = next->val;
		err = sensor_write_reg(client, next->addr, val);
		if (err)
		return err;
	}
	return 0;
}

static int sensor_set_mode(struct sensor_info *info, struct ov2655_mode *mode)
{
	int sensor_table;
	int err;

	if (mode->xres == 1600 && mode->yres == 1200)
		sensor_table = SENSOR_MODE_1600x1200;
	else if (mode->xres == 1280 && mode->yres == 720)
		sensor_table = SENSOR_MODE_1280x720;
	else if (mode->xres == 800 && mode->yres == 600)
		sensor_table = SENSOR_MODE_800x600;
	else if (mode->xres == 640 && mode->yres == 480)
		sensor_table = SENSOR_MODE_640x480;
	else {
		pr_err("%s: invalid resolution supplied to set mode %d %d\n",
			__func__, mode->xres, mode->yres);
		sensor_table = SENSOR_MODE_640x480;
	}
	if ((info->mode == SENSOR_MODE_1600x1200) &&
		(sensor_table == SENSOR_MODE_640x480)) {
		err = sensor_write_table(info->i2c_client, return_to_vga);
	} else if ((info->mode == SENSOR_MODE_1600x1200) &&
				(sensor_table == SENSOR_MODE_800x600)) {
		err = sensor_write_table(info->i2c_client, return_preview_uxga_to_svga);
	} else {
		err = sensor_write_table(info->i2c_client, mode_table[sensor_table]);
	}
	if (err)
		return err;

	info->mode = sensor_table;
	return 0;
}

static long sensor_ioctl(struct file *file,
		unsigned int cmd, unsigned long arg)
{
	struct sensor_info *info = file->private_data;
	int err=0;

	switch (cmd) {
	case OV2655_MIPI_IOCTL_SET_MODE:
	{
		struct ov2655_mode mode;
		if (copy_from_user(&mode, (const void __user *)arg,
			sizeof(struct ov2655_mode))) {
			return -EFAULT;
		}

		return sensor_set_mode(info, &mode);
	}
	case OV2655_MIPI_IOCTL_GET_STATUS:
	{
		return 0;
	}
	case OV2655_MIPI_IOCTL_SET_COLOR_EFFECT:
	{
		u8 coloreffect;

		if (copy_from_user(&coloreffect, (const void __user *)arg,
			sizeof(coloreffect))) {
			return -EFAULT;
		}
		switch(coloreffect) {
		case YUV_ColorEffect_None:
			err = sensor_write_table(info->i2c_client,
						ColorEffect_None);
			break;
		case YUV_ColorEffect_Mono:
			err = sensor_write_table(info->i2c_client,
						ColorEffect_Mono);
			break;
		case YUV_ColorEffect_Sepia:
			err = sensor_write_table(info->i2c_client,
						ColorEffect_Sepia);
			break;
		case YUV_ColorEffect_Negative:
			err = sensor_write_table(info->i2c_client,
						ColorEffect_Negative);
			break;
		case YUV_ColorEffect_Solarize:
			err = sensor_write_table(info->i2c_client,
						ColorEffect_Solarize);
			break;
		case YUV_ColorEffect_Posterize:
			err = sensor_write_table(info->i2c_client,
						ColorEffect_Posterize);
			break;
		default:
			break;
		}

		if (err)
			return err;

		return 0;
	}
	case OV2655_MIPI_IOCTL_SET_WHITE_BALANCE:
	{
		u8 whitebalance;
		if (copy_from_user(&whitebalance, (const void __user *)arg,
			sizeof(whitebalance))) {
			return -EFAULT;
		}
		switch(whitebalance) {
		case YUV_Whitebalance_Auto:
			err = sensor_write_table(info->i2c_client,
						Whitebalance_Auto);
			break;
		case YUV_Whitebalance_Incandescent:
			err = sensor_write_table(info->i2c_client,
					Whitebalance_Incandescent);
			break;
		case YUV_Whitebalance_Daylight:
			err = sensor_write_table(info->i2c_client,
					Whitebalance_Daylight);
			break;
		case YUV_Whitebalance_Fluorescent:
			err = sensor_write_table(info->i2c_client,
					Whitebalance_Fluorescent);
			break;
		default:
			break;
		}

		if (err)
			return err;

		return 0;
	}

	case OV2655_MIPI_IOCTL_SET_SCENE_MODE:
		return 0;

	case OV2655_MIPI_IOCTL_SET_EXPOSURE:
	{
		u8 exposure;

		if (copy_from_user(&exposure, (const void __user *)arg,
			sizeof(exposure))) {
			return -EFAULT;
		}
		switch(exposure) {
		case YUV_Exposure_Number0:
			err = sensor_write_table(info->i2c_client, Exposure_0);
			break;
		case YUV_Exposure_Positive1:
			err = sensor_write_table(info->i2c_client, Exposure_1);
			break;
		case YUV_Exposure_Positive2:
			err = sensor_write_table(info->i2c_client, Exposure_2);
			break;
		case YUV_Exposure_Negative1:
			err = sensor_write_table(info->i2c_client,
						Exposure_Negative_1);
			break;
		case YUV_Exposure_Negative2:
			err = sensor_write_table(info->i2c_client,
						Exposure_Negative_2);
			break;
		default:
			break;
		}

		if (err)
			return err;

		return 0;
	}
	default:
		return -EINVAL;
	}
	return 0;
}

static int sensor_open(struct inode *inode, struct file *file)
{
	file->private_data = info;
	if (info->pdata && info->pdata->power_on)
		info->pdata->power_on();
	info->mode = -1;
	return 0;
}

static int sensor_release(struct inode *inode, struct file *file)
{
	if (info->pdata && info->pdata->power_off)
		info->pdata->power_off();
	file->private_data = NULL;
	info->mode = -1;
	return 0;
}


static const struct file_operations sensor_fileops = {
	.owner = THIS_MODULE,
	.open = sensor_open,
	.unlocked_ioctl = sensor_ioctl,
	.release = sensor_release,
};

static struct miscdevice sensor_device = {
	.minor = MISC_DYNAMIC_MINOR,
	.name = SENSOR_NAME,
	.fops = &sensor_fileops,
};

static int sensor_probe(struct i2c_client *client,
			const struct i2c_device_id *id)
{
	int err;

	pr_info("ov2655 %s\n",__func__);

	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);
	if (!info) {
		pr_err("ov2655 : Unable to allocate memory!\n");
		return -ENOMEM;
	}
	err = misc_register(&sensor_device);
	if (err) {
		pr_err("ov2655 : Unable to register misc device!\n");
		kfree(info);
		return err;
	}

	info->pdata = client->dev.platform_data;
	info->i2c_client = client;
	i2c_set_clientdata(client, info);
	info->mode = -1;
	return 0;
}

static int sensor_remove(struct i2c_client *client)
{
	struct sensor_info *info;

	pr_info("ov2655 %s\n",__func__);
	info = i2c_get_clientdata(client);
	misc_deregister(&sensor_device);
	kfree(info);
	return 0;
}

static const struct i2c_device_id sensor_id[] = {
	{SENSOR_NAME, 0 },
	{ },
};

MODULE_DEVICE_TABLE(i2c, sensor_id);

static struct i2c_driver sensor_i2c_driver = {
	.driver = {
		.name = SENSOR_NAME,
		.owner = THIS_MODULE,
	},
	.probe = sensor_probe,
	.remove = sensor_remove,
	.id_table = sensor_id,
};

static int __init ov2655_sensor_init(void)
{
	pr_info("ov2655 sensor init!\n");
	return i2c_add_driver(&sensor_i2c_driver);
}

static void __exit ov2655_sensor_exit(void)
{
	pr_info("ov2655 sensor exit!\n");
	i2c_del_driver(&sensor_i2c_driver);
}

module_init(ov2655_sensor_init);
module_exit(ov2655_sensor_exit);

